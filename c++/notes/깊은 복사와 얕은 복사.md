# 객체의 깊은 복사와 얕은복사
C++ 에서 객체 복사 연산을 할 때, 그리고 복사 생성자와 연산자를 구현 할 때, 깊은 복사와 얕은 복사라는 개념이 등장한다.

## 얕은 복사
얕은 복사는 말 그대로 객체의 값들을 그대로 복사 대상에 복사하는 것이다. 쉽게 말해서 객체 A에게 10이라는 값이 있으면, 10을 그대로 B에게 복사 하는것이다. 이러한 복사는 객체의 멤버에 포인터 등 메모리와 관련된 변수가 존재하지 않는다면 문제가 없지만, 만약, 객체에 포인터와 같은 메모리 관련 멤버 변수가 있다면, 문제가 발생한다. 

객체가 포인터 A가 있다고 가정하자. 이 포인터 A는 a라는 주소를 가르키는 포인터이다. 이 객체를 얕은 복사를 통해 다른 객체로 복사한다고 가정하자. 그러면 복사가 진행되는 객체의 포인터도 포인터 A의 주소값이 그대로 복사가 되어서, 원본 객체, 복사된 객체의 포인터 A가 둘 다 a 주소를 가르키는 상황이 발생한다. 이렇게 되면, 만약 두 객체 중 하나가 소멸하며 포인터 A를 소멸시킨다면, 남아있는 나머지 하나의 객체의 포인터 A가 이미 할당 해제된 메모리 주소를 가르키고 있는 상황이 발생한다.

위와 같은 상황을 방지하기 위해서 객체의 깊은 복사를 수행하는 연산자 혹은 생성자를 직접 생성 해 주어야 한다.

## 깊은 복사
깊은 복사를 위해서는 동적 할당된 멤버 변수들을 얕게 메모리 주소만 복사하는 것이 아니라, 복사하는 과정에서 새롭게 멤버 변수를 동적 할당하고, 복사 할 객체의 멤버 변수의 값을 복사 해야 한다.
```cpp
// 깊은 복사 예시 (ptr 이라는 int* 를 멤버로 가지고 있다고 가정)
ClassName(const ClassName& other){
    ptr = new int; // 복사할 값을 저장할 메모리를 새롭게 할당
    *ptr = *other.ptr; // 주소가 아닌 값을 직접 복사
}
```

위와 같이 깊은 복사를 진행 해야, 두 객체 멤버가 하나의 주소를 가르키는 문제를 피할 수 있다.