# 클래스의 생성자
클래스의 생성자가 실행 되기 전에는 생성자의 코드블럭, 즉, {}로 이루어진 블럭 이전에 미리 실행되는 일종의 **선처리** 구간이 존재한다.
## 생성자의 선처리 구간
생성자의 선처리 구간에서는 상속한 클래스의 생성자가 암시적으로 호출되고, 만약 다른 클래스간의 관계에서 HAS-A 관계가 있다면, 해당 클래스 객체의 생성자도 호출된다.

```cpp
class Player{
    // Player 의 로직
}

class Warrior : public Player{ // Player를 상속
    Warrior() 
    // 선처리 구간
    // 이 구간에서 Player의 기본 생성자가 암시적 호출됨
    // 또한 Weapon 객체의 기본 생성자도 호출됨
    {
        // 생성자 로직
    }

public:
    Weapon _weapon;
}
```

위와 같이 클래스 생성자의 선처리 구간에서 상속 클래스와 소유한 객체의 생성자 호출을 진행하게 된다. 하지만 만약에 소유한 객체에 기본 생성자가 아닌 다른 생성자를 호출하고 싶다면 생성자 로직 안에 _weapon = Weapon(SWORD)의 형태로 생성 하게 된다면 되는걸까?

위의 방식으로 초기화를 하게 된다면, 해당 생성자가 호출된 객체가 생성되기는 한다. 하지만, 선처리 영역에서 이미 기본 생성자가 한번 호출되어서 생성된 객체 위에 또 다시 다른 생성자를 명시적으로 또 한번 더 호출하게 되어서, 기본 생성자로 생성된 객체는 이때 소멸하고, 새로운 객체가 생성되게 된다.

즉, 두번의 객체 생성이 이루어 진다는 것이다. 이러한 동작을 방지하기 위해서 **초기화 리스트**라는 것이 존재한다.

## 초기화 리스트
```cpp
class Warrior : public Player{ // Player를 상속
    Warrior() : Player(100), _weapon(SWORD), MAX_HP(100)
    // 선처리 구간
    {
        // 생성자 로직
    }

public:
    Weapon _weapon;
    const MAX_HP;
}
```

위와 같은 형식으로 변수의 초기화를 진행하게 된다면, 객체의 생성과 동시에 선처리 구간에서 초기화를 진행하는 것과 동일한 시점에 처리하는 것과 동일하기 때문에 소유한 객체, 상속 받은 객체의 초기화 뿐만 아니라, const, 참조 변수들도 초기화 해 줄수 있다.