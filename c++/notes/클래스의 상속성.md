# 클래스의 3대 속성
C++ 클래스의 3대 속성에는 상속성, 은닉성, 다형성이 존재한다. 이번 포스트에서는 상속성에 대해서 설명한다.

## 클래스의 상속성
만약, 여러 클래스가 같은 공통 로직과 변수들을 가진다면, 이는 클래스 상속을 통해 효율적으로 로직과 변수를 재활용 할 수 있다. 먼저, 상속이란 부모가 자식에게 재산 혹은 재물을 물려주는 것을 뜻한다. 이와 같은 의미로 클래스의 상속도 부모 클래스로 부터 자식 클래스가 함수와 변수를 물려받는 것을 의미한다.

```cpp
class Player{
public:
    Player();
    Player(int hp);
    void Move(){};
    void Attack(){};
public:
    int _hp;
    int _attack;
    int _defence
}

class Knight : public Player{
public:
    int _stemina;
}
```

위와 같이 Player의 공통적인 로직과 변수를 Knight가 상속 받아서, 효율적인 코드를 작성 할 수 있다. Knight는 상속 받은 Player의 변수와 함수에 접근해서 사용할 수 있다.

## 클래스 상속에서 메모리 할당
부모 클래스를 상속한 자식 클래스의 메모리는 어떤 형식으로 할당될까? 먼저 자식 클래스를 생성 할 때, 부모 클래스로 부터 상속받은 변수들을 대상으로 부모 클래스와 같은 크기의 메모리를 먼저 할당한다. 그리고 다음으로 자식 클래스에 추가적으로 존재하는 변수들에 대한 크기만큼 메모리를 할당 하게 된다.
```cpp
// 만약 Knight를 생성한다고 가정하면 아래와 같이 변수가 할당 된다.
// [Player] + [Knight] -> 이렇게 메모리가 할당된다
// [[Player] [Knight]] -> 이런 형식으로 두 클래스에 존재하는 변수가 각각의 공간에 할당 되어 하나의 Knight 클래스의 메모리 공간을 형성한다.
```

## 클래스 상속의 생성자와 소멸자
부모 클래스를 상속받은 자식 클래스의 생성자와 소멸자는 자식 클래스가 생성, 소멸 될때 부모 클래스의 생성자와 소멸자도 함께 호출 된다. 이때, 부모 클래스의 생성자가 먼저 호출되는데, 실제로 부모의 생성자가 먼저 호출 되는 것이 아닌, 자식 클래스의 생성자로 진입 하고, 자식 클래스 생성자의 로직이 실행 되기 전, 부모 클래스의 생성자가 실행 되고, 이어서 자식 클래스 생성자의 로직이 실행 되는 것이다. 간단하게 말해서 생성자 함수의 실행 순서라기 보다는, 생성자 로직의 실행 순서는 **부모 클래스의 생성자 -> 자식 클래스의 생성자** 순으로 실행된다.

소멸자는 생성자의 순서와 반대로 자식 클래스의 소멸자가 호출 된 후 부모 클래스의 소멸자가 호출된다.

다시말해, 생성과 소멸의 순서는, **부모 생성 -> 자식 생성 -> 자식 소멸 -> 부모 소멸**의 순서로 진행된다.

### 기본 생성자가 아닌 생성자 호출
만약 자식 클래스를 생성 할 때, 대부분 명시적으로 표시하지 않는 이상, 어떤 생성자를 호출 하든, 부모 클래스의 기본 생성자가 호출 된다. 하지만 만약 자식 클래스의 생성 과정에서 부모 클래스의 다른 생성자를 호출하고 싶다면 아래와 같은 문법으로 부모 클래스의 생성자를 명시적으로 호출 할 수 있다.
```cpp
class Knight : public Player{
public:
    Knight() : Player(100){
        // 생성자 로직
    }
public:
    int _stemina;
}
```

위 코드는 Knight를 생성 할 때, Player의 타입 변환 생성자를 호출 하도록 명시적으로 표시한 코드이다. 이와 같이 **자식 생성자() : 부모 생성자 ()**의 형식으로 부모 클래스의 기본 생성자가 아닌 다른 생성자를 호출 할 수 있다.