# 객체 연산자 오버로딩
C++에서는 객체의 연산을 위한 연산자를 직접 구현 할 수 있도록 연산자 오버로딩을 지원한다. 이는 전역으로도 구현 할 수 있고, 멤버로도 구현 할 수 있다. 두가지 방식 중 어떤 방식이 낫다기 보다는 각각의 목적에 따라서 구현 방식이 달라진다.

## 연산자 오버로딩 구현
```cpp
class MyClass{
public: 
    MyClass operator+ (int val){
        _val += val;
        return *this;
    }

    bool operator== (const MyClass& other){
        return (_val == other._val);
    }


    int _val;
}
```

덧셈 연산자는 위와같이 구현하게 되는데, 인자로는 일반 타입 혹은 같은 클래스의 타입을 넣어도 된다. 일반적으로 왼쪽 인자를 기준으로 계산이 되는데, 이는 num1 + num2 과 같은 연산에서 왼쪽의 num1 을 기준으로 연산자 함수를 호출하게 된다는 의미이다. 또한, 연산자 오버로딩을 구현 할 때, 해당 클래스를 생성하여 결과값을 반환하게 된다.

== 연산자와 같이 비교 연산자도 구현 할 수 있는데, 이때는 일반적으로 같은 타입의 다른 클래스의 비교 연산을 수행한다.

### 복사 대입 연산자 오버로딩
클래스의 복사 대입 연산을 수행하는 연산자도 구현 할 수 있는데, 이는 깊은 복사를 직접 구현하기 위한 연산자를 구현하는 것이다. 일반적으로 컴파일러가 얕은 복사를 위한 복사 대입 연산자를 구현 해주는데, 이는 단순히 변수 값들을 그대로 복사하는 연산자로, 포인터 내부의 값을 복사해주지 않고, 단순히 포인터의 주소 값만 복사 해주기 때문에 메모리 누수의 위험이 있다. 그렇기 때문에 깊은 복사를 수행하기 위한 복사 대입 연산자도 직접 구현 해주어야 한다.

```cpp
class MyClass{
public: 
    MyClass operator+ (int val){
        _val += val;
        return *this;
    }

    bool operator== (const MyClass& other){
        return (_val == other._val);
    }

    MyClass& operator= (const MyClass& other){
        _val = other._val;
        delete _arr;
        arr = new int;
        *arr = *other._arr;
        return *this;
    }

    int _val;
    int* _arr;
}
```

### 증감 연산자 오버로딩
```cpp
// 전위 연산자
MyClass& operator++() {
    _val++;
    return *this;
}

// 후위 연산자
MyClass operator++(int) {
    MyClass temp = *this; // 1. 현재 객체의 값을 임시로 저장
    _val++;              // 2. 현재 객체의 값을 1 증가
    return temp;          // 3. 임시로 저장했던 값(증가 전의 값)을 반환
}
```
연산자 오버로딩을 통해서 ++, -- 와 같은 증감 연산자도 구현 해 줄수 있다. 이를 구현 할땐 결과 값을 저장하는 임시 객체를 복사하여 대입해야 하기 때문에 복사 대입 연산자를 함께 구현 하는것이 좋다. 또한 ++(++num)와 같은 연산 체이닝을 위해서 임시 객체 혹은 자기 자신의 객체 참조를 반환해야 한다.

또한 후위 연산자와 전위 연산자의 구현을 구분하기 위해서, 후위 연산자의 인자에는 int를 넣어서 구분한다.