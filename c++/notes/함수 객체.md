# 함수 객체 (Functor)
함수 객체란, 함수 포인터의 단점을 극복 하는 구현 방법으로, 클래스와 연산자 오버로딩을 통해서 구현 될수있다.

함수 포인터의 단점은 아래와 같다.
- 상태의 저장이 불가능 하다. 즉, 객체처럼 내부에서 멤버를 가지거나 상태가 저장 될 수 없다.
- 원본 함수와 시그니처 (함수의 형태->인자, 리턴 값 등)이 다르면 사용할 수 없다.

함수 객체는 위와 같은 단점들을 극복한 형태의 객체이다.

## 함수 객체의 구현
함수 객체는 일반적인 클래스와 같은 방법으로 정의 할 수 있다. 일반적인 클래스에 ()연산자를 오버로딩 해서 함수 처럼 사용하는 것이 함수 객체이다.

```cpp
class Functor{
public:
    Functor(int val) : _val(val) {}

    void operator()(void){
        // logic
    }

    int operator()(int a, int b){
        return _val + a + b;
    }
private:
    int _val
}

Functor functor(10);
functor();
int res = functor(10, 10);
```

위 함수 객체는 내부에 _val 이라는 상태를 유지하고, () 연산자 오버로딩을 통해 함수처럼 호출 될 수 있다. 함수 객체는 위 예시와 같이 연산자 오버로딩을 통해서 여러 형태의 호출이 가능하게된다.

### 함수 객체의 장점
함수 객체의 최대 장점은 바로 함수 객체의 실행 시점과 처리 시점을 분리 할 수있다는 것이다. 이말은 즉, 함수 객체를 이용해서 **비동기적**인 동작이 가능해진다는 것이다.

```cpp
class Task{
    void operator()(void){
        // logic
    }

    int operator()(int a, int b){
        return _val + a + b;
    }
}

Task task; // 작업 객체를 생성한다 -> 작업을 배정
sleep(10); // 비동기적 상황을 만들기 위해 10초 대기
task(10, 10); // 실행된 작업을 처리
```

위와 같이 비동기적으로 동작하는 함수를 구현해서 작업의 처리 시점을 조절 할 수 있다.