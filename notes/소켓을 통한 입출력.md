# 소켓 입출력
서버 혹은 클라이언트에서 생성한 소켓을 통해 데이터를 전송하고 수신하는 방법은 다음의 함수들을 이용해 이루어진다.

## linux
### 리눅스 환경의 소켓 입출력
리룩스 환경에서의 소켓 입출력은 파일 디스크립터를 사용하는 특징으로 인해서 파일의 입출력에 사용하는 함수와 동일한 함수를 사용할 수 있다. 또한 소켓 입출력에만 사용되는 send, recv 의 함수도 윈도우와 같은 방식으로 사용이 가능하다. 하지만 아래에선 read와 write 함수를 대상으로 설명하겠다.

### 데이터의 전송
```cpp
ssize_t write(int fd, void* buf, size_t nbytes);
```
- **int fd**: 소켓의 파일 디스크럽터 값
- **void\* buf**: 전송할 데이터가 저장된 버퍼의 주소값
- **size_t nbytes**: 전송할 데이터의 크기 값
- **return value**: 발신한 데이터의 바이트 수

위 함수의 인자들에서 가장 중요한 인자는 nbytes 라고 할 수 있다. 만약 전송 할 버퍼의 크기보다 적은 값을 넣는다면, 상대방에게 수신할 데이터가 잘린채로 일부분만 전송 될 것이고, 만약 버퍼의 값 보다 더 큰값을 넣는다면, 버퍼의 범위를 넘어서는 주소에서 가져온 값이 전송되거나, 아직 초기화 되지 않은 버퍼의 부분에서 값을 가져와서 엉뚱한 값이 같이 전송 될수도 있기 때문이다.
### 데이터의 수신
```cpp
ssize_t read(int fd, void* buf, size_t nbytes);
```

- **int fd**: 소켓의 파일 디스크럽터 값
- **void\* buf**: 수신할 데이터가 저장된 버퍼의 주소값
- **size_t nbytes**: 수신할 데이터의 크기 값
- **return value**: 수신한 데이터의 바이트 수

위 함수의 인자들은 write 함수와 같은 값을 가진다. 하지만 write 함수와 다르게 주의 할 점은 수신받을 데이터를 저장할 버퍼에 이미 값이 존재한다면, read 함수로 인해 이 값이 덮어 씌워진다는 점이다. 또한 nbytes 인자에는 받을 데이터의 크기를 넣는데, 보통 수신할 데이터의 정확한 크기를 알지 못하기 때문에, 버퍼의 사이즈 혹은 버퍼 사이즈에서 1을 뺀 값을 넣는다.

nbytes에 버퍼 사이즈에 1을 뺀 값을 넣는 이유는, 만약 send 함수로 받는 데이터가 문자열이라면, send 함수는 문자열의 종료를 알리는 바이트를 자동으로 삽입해주지 않는다. 그렇기 때문에 버퍼의 마지막 값을 문자열 종료 바이트로 채우기 위해 위와 같은 값을 사용하는것이다.

## windows
윈도우 환경에서의 데이터 수신과 송신 함수도 리눅스의 함수와 이름만 다르고 대부분의 인자들과 각 인자의 역할, 반환 값도 같다. 그러므로 함수의 형태만 서술하겠다.

### 데이터의 전송
```cpp
int send(SOCKET s, const char* buf, int len, int flags);
```
위 함수가 윈도우 환경에서 데이터를 전송하는 함수이다. 이 함수가 리눅스의 write 함수와 다른점은 마지막에 flags라는 인자가 존재한다는 것인데, 이 인자는 데이터 전송시 적용할 다양한 옵션을 전달하는 역할을 한다.

### 데이터의 수신
```cpp
int recv(SOCKET s, const char* buf, int len, int flags);
```
위 함수 또한 flags 인자를 제외한 기능은 리눅스의 read 함수와 같다.