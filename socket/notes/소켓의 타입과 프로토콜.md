# 소켓의 타입과 프로토콜
### 프로토콜이란?
컴퓨터 상호간의 대화에 필요한 통신 "규약" -> 서로 데이터를 주고받기 위해서 정해진 약속

## 소켓의 생성
## linux
```cpp
int socket(int domain, int type, int protocol);
// 성공시 소켓의 파일 디스크럽터 반환, 실패시 -1 반환
```
- **int domain**: 소켓의 도메인을 결정하는 인자. AF_INET, PF_INET 등의 소켓 통신에 이용할 인터넷 프로토콜 체계를 입력한다. (여기서 AF_INET과 PF_INET은 사실 대부분의 운영체제에서 동일한 값을 지닌다.)
- **int type**: 소켓의 타입을 결정하는 인자. 소켓을 TCP 혹은 UDP로 설정 할것인지를 이 인자를 통해 결정한다. TCP 소켓 생성은 SOCK_STREAM, UDP 소켓은 SOCK_DGRAM 이다.
- **int protocol**: 통신에 사용할 프로토콜 정보 전달 (일반적으로는 0을 전달)

## windows
윈도우 환경에서 소켓의 생성은 리눅스 환경에서 소켓의 생성과 거의 동일한 함수를 사용한다.
```cpp
SOCKET socket(int af, int type, int protocol);
// 성공시 SOCKET 핸들 반환, 실패시 INVALID_SOCKET 반환
```
여기서 반환값이 SOCKET이라는 점이 리눅스의 socket함수와 다른점인데, SOCKET은 윈도우 환경에서의 소켓을 지칭하는 handle 값이다 (정수 값). 모든 인자는 리눅스 환경과 동일하다.

### 소켓의 타입
- **SOCK_STREM (연결 지향형 소켓)**: 이 타입의 소켓은 데이터의 전송을 보장해주는 소켓이다. 즉, 데이터가 중간에 유실 없이 전송됨을 보장해준다는 의미이다. 또한 데이터가 전송된 순서대로 수신된다. 마지막 특징은 데이터의 경계가 존재하지 않는다는 것이다. 데이터의 경계가 존재하지 않는다는 의미는 만약 100바이트의 데이터를 전송했을때, read 함수를 몇번 호출해서 데이터를 수신하느냐가 중요하지 않다는 것이다. 즉 50, 50 바이트 단위로 수신하느냐, 100 바이트를 한번에 수신하느냐가 큰의미를 갖지 않는다는 것이다. 한 문장으로 연결지향성 소켓을 정리한다면 -> **신뢰성 있는 순차적 바이트 기반의 소켓** 이다.

- **SOCK_DGRAM (비 연결 지향성 소켓)**: 이 소켓의 가장 큰 특징은 전송 순서와 관계없이 기장 빠른 전송을 지향한다는 것이다. 그렇기 때문에 전송 순서에 따른 데이터 수신 순서를 보장하지 않는다. 그리고 데이터가 제대로 수신되었는지 확인 하지 않기 때문에 데이터의 유실 가능성이 존재한다. 또한 연결지향성 소켓과는 다르게 데이터의 경계가 존재한다. 그리고 전송할수 있는 데이터의 크기도 제한된다. 비 연결 지향성 소켓을 정리한다면 -> **신뢰성과 순차성이 보장되지 않는, 빠른 데이터 전송을 목적으로 하는 소켓** 이다.